la gestion de la mémoire du tas se fait du haut vers le bas. 

exécution de code asm -> gros bloc de mémoire tas alloué
chaque appel de fonction dans ce code, une sous partie de ce gros espace (stack frame) est alloué pour cette fontion du haut vers le bas de la mémoire totale
appel imbriqué, les stack frame sont empilés du haut vers le bas, en bas l'appel le plus profond


+---------------------+  <-- Higher addresses
| Return Address      |  <-- Pushed automatically by call
+---------------------+
| Caller’s %rbp       |  <-- Pushed in function prologue (push %rbp)
+---------------------+  <-- New %rbp is set here
| Local variables ... |
+---------------------+  <-- Lower addresses

return address permet de sortir de la fonction et retourner au bon endroit pour exécuter la suite du code asm
base caller permet de sortir de la fonction et retourner au bon endroit sur le tas

quand t'appelle une fonction, il se passe deux choses : tu sauvegardes le current rbp dans le stack frame de la nouvelle fonction appelé (décrit juste au dessus)
comme ça tout en haut du stack frame, t'as les infos pour sortir de la fonction
et tu set le rbp sur le current stack pointer (rsp) celui qui bouge, comme ça le nouveau stack frame devient le current

les objets counter (ceux utilisés pour la RAM) sont des int32 allant de -2 147 483 648 à 2 147 483 647

les registres (apparement tous) ont deux variantes de nom 32 bits/64 bits, modifier le registre via son nom 32 bit reset à 0 les bits supérieurs
de la même manière il y a des variantes d'instruction (apparement ici encore la plupart)
b: indicates 8‑bit operations (byte).
w: indicates 16‑bit operations (word).
l: indicates 32‑bit operations (long).
q: indicates 64‑bit operations (quad).

For the original registers (like RAX, RBX, RCX, RDX), there is a consistent naming convention:
    The 64‑bit register: e.g., RAX
    The lower 32‑bit part: prefix with "E", e.g., EAX
    The lower 16‑bit part: drop the prefix, e.g., AX
    The lower 8‑bit part: for these registers, the low byte is AL and the high byte of the 16‑bit register is AH

For registers R8 through R15, the naming is slightly different:
    The 64‑bit register: e.g., R8
    The lower 32‑bit part: add a "D", e.g., R8D
    The lower 16‑bit part: add a "W", e.g., R8W
    The lower 8‑bit part: add a "B", e.g., R8B

certaines instructions peuvent s'exécuter sur le tas mais d'autres non (t[i]) -> faut multiplier i par la taille des éléments de t puis ajouter à l'adresse de t etc..
un même code asm peut faire les deux sur une même variable

spilled -> mettre sur le tas

Bonus : 
main a lui même un caller (souvent appelé crt0)

première strat : soit n la taille d'une page, on a un counter th : "top heap", a chaque fois qu'il devient plus grand qu'un multiple de n, on alloue une page en plus
des instant count trigger pour chaque valeur de multiple th qui activent les count triggers 

pour la création du tas, le pb des count trigger qui active si c est dans [a,b] et que item id n va de a à b pourquoi
pas utiliser un item compare trigger après si vrai alors on écrit vraiment sinon on stop trigger (est ce vraiment nécessaire ?) et après on ramène sur le count trigger avec un spawn trigger

pour la pagination faire une page de taille plutôt qu'un compteur global, utiliser un algo très simple, genre first-fit
pour pouvoir défragmenter en un seul tick, le faire page par page mais tout d'affiler (est ce qu'on s'en fout pas un peu de défragmenter ?)

après une instruction set, il y aura en principe nécessairement un movzbl. Il faut donc les combiner

	sete	%al
	setne	%al
	setle	%al
	setg	%al
	setge	%al

    set.. %al 
    movzbl %al, %eax
    
    ne pas oublier d'enlever 1 à chaque fois qu'on lit un set.. pendant le pre-processing puisqu'on combine des instructions

-> checker toutes les variantes de set

multiplication et division ne touchent pas à CF et OF (en principe non mais en pratique ça change rien)
pour les divisions, utiliser l'item edit trigger (je crois que c'est à cause de vers où se fait l'arrondi, il y avait un pb avec le pickup trigger je crois)
les overflow pour la multiplication sont à proscrire

si ~9K lignes de code ne suffit pas, avec 10 groupesID grâce au théorème de Sperner, on peut créer 184756 sous ensemble de combinaisons de groupeID deux à deux distincts
opti : analyser l'asm, quand il n'y a pas de jump, alors on sait que c'est deux instruction consécutives, alors on peut réduire le nombre de toggle trigger utilisé (ne pas toggle ou untoggle un groupe respectivement déjà toggle ou untoggle )


on enlève les variantes ...w et ...b des opérations arithmetiques, j'ai aussi enlevé pour les bitwise op mais je sais plus pourquoi
faire des optimisations pour des "test %eax %eax" -> ici on peut juste utiliser un instant count trigger "=0"

https://www.raylib.com/cheatsheet/cheatsheet.html

ah oui faut faire gaffe, avec l'asm imbriqué, ça peut poser des problèmes avec la gestion de esp et ebp, peut être pas mais faut faire gaffe, 
je crois que c'est pour cela que j'ai décidé d'utiliser -fno-omit-frame-pointer puis aussi faire gaffe parce que si esi et edi sont utilisés alors ça détruit tout, 
dans ce cas utiliser deux items id spécifiquement pour cela

enlever les loads d'inputs et créer deux sets de trigger pour chaque instructions pour chaque cas à la place 
